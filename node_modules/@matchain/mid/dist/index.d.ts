import React$1, { PropsWithChildren, CSSProperties, ReactNode } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as viem from 'viem';
import { SignableMessage, Hex, TransactionSerializable } from 'viem';

type LoginMethodType = 'wallet' | 'email' | 'google' | 'X' | 'telegram'
type IEnvName = 'main' | 'dev' | 'test'
type IMatchEvents = {
    onLogin?: (data: {
        mid?: string;
        token: string;
        did: string
    }) => void
    onLogout?: () => void,
    onBind?: (data: {
        type: string
    }) => void
}

type OverviewInfo = {
    score: number,
    total_assets: number,
    wallets: number,
    followers: number,
    sbt: number,
    is_kyc: boolean,
    is_poh: boolean,
    mid: string
    user_identity: string
    identities: { [key: string]: string }
    did: string
    address: string
    username?:string
}

type ModalProps = PropsWithChildren & {
    isOpen: boolean,
    width?: number
}

type ModalWithHeaderProps = ModalProps & {
    onBack?: () => void,
    onClose?: () => void,
    title?: string
    showClose?: boolean
}

type InputProps = {
    placeholder: string,
    value: string,
    onChange: (e?: any) => void,
    disabled?: boolean,
    readonly?: boolean
    type?: string
    maxLength?: number
    after?: React.ReactNode
}

type LoginBoxProps = {
    methods?: LoginMethodType[],
    inModal?: boolean
}
type LoginPanelProps = {
    header?: React.ReactNode
    onClose?: () => void
} & LoginBoxProps
type LoginModalProps = LoginPanelProps & ModalProps
type EmailModalProps = ModalProps & {
    onClose?: () => void,
    onBack?: () => void,
    onLogin?: () => void
}
type ButtonProps = {
    size?: 'sm' | 'df' | 'lg',
    type?: "button" | "submit" | "reset",
    rounded?: boolean,
    block?: boolean,
    disabled?: boolean,
    loading?: boolean,
    children?: React.ReactNode,
    onClick?: () => void,
    highlight?: boolean,
    style?: CSSProperties
    className?: string
}

type MatchContextType = {
    env: IEnvName;
    appid: string;
    endpoints: {
        login: string;
        back: string;
    };
    events?: IMatchEvents;
    login: (data: {
        mid: string;
        token: string;
    }) => Promise<void>;
    theme: "light" | "dark";
};
declare const MatchProvider: React$1.FC<{
    children: ReactNode;
    appid: string;
    env?: IEnvName;
    events?: IMatchEvents;
    theme?: "light" | "dark";
}>;
declare const useMatch: () => MatchContextType;

declare function EmailModal({ isOpen, width, onClose, onBack, onLogin }: EmailModalProps): react_jsx_runtime.JSX.Element;

declare function Field({ label, children, error }: {
    label: ReactNode;
    error?: ReactNode;
} & PropsWithChildren): react_jsx_runtime.JSX.Element;

declare function Input({ onChange, type, after, ...props }: InputProps): react_jsx_runtime.JSX.Element;

declare function Button({ size, disabled, loading, children, onClick, highlight, block, type, rounded, className, style }: ButtonProps): react_jsx_runtime.JSX.Element;

declare function LoginBox({ methods, inModal }: LoginBoxProps): react_jsx_runtime.JSX.Element;

declare function Modal({ children, isOpen, width }: ModalProps): react_jsx_runtime.JSX.Element;
declare function ModalWithHeader({ children, onBack, onClose, title, showClose, ...props }: ModalWithHeaderProps): react_jsx_runtime.JSX.Element;

declare function LoginButton({ loginRender, methods, onLoginClick, ...props }: Omit<ButtonProps, 'onClick' | 'highlight'> & {
    loginRender?: () => JSX.Element;
    methods?: LoginMethodType[];
    onLoginClick?: () => void;
}): react_jsx_runtime.JSX.Element;

declare function LoginPanel({ header, onClose, ...props }: LoginPanelProps): react_jsx_runtime.JSX.Element;

declare function LoginModal({ isOpen, width, ...props }: LoginModalProps): react_jsx_runtime.JSX.Element;

declare function UsernameModal({ title, isOpen, onSuccess, ...props }: ModalWithHeaderProps & {
    onSuccess?: () => void;
}): react_jsx_runtime.JSX.Element;

declare function PasswordModal({ title, isOpen, onSuccess, ...props }: ModalWithHeaderProps & {
    onSuccess?: () => void;
}): react_jsx_runtime.JSX.Element;

declare const index$1_Button: typeof Button;
declare const index$1_EmailModal: typeof EmailModal;
declare const index$1_Field: typeof Field;
declare const index$1_Input: typeof Input;
declare const index$1_LoginBox: typeof LoginBox;
declare const index$1_LoginButton: typeof LoginButton;
declare const index$1_LoginModal: typeof LoginModal;
declare const index$1_LoginPanel: typeof LoginPanel;
declare const index$1_Modal: typeof Modal;
declare const index$1_ModalWithHeader: typeof ModalWithHeader;
declare const index$1_PasswordModal: typeof PasswordModal;
declare const index$1_UsernameModal: typeof UsernameModal;
declare namespace index$1 {
  export { index$1_Button as Button, index$1_EmailModal as EmailModal, index$1_Field as Field, index$1_Input as Input, index$1_LoginBox as LoginBox, index$1_LoginButton as LoginButton, index$1_LoginModal as LoginModal, index$1_LoginPanel as LoginPanel, index$1_Modal as Modal, index$1_ModalWithHeader as ModalWithHeader, index$1_PasswordModal as PasswordModal, index$1_UsernameModal as UsernameModal };
}

declare function useUserInfo(): {
    loginByTelegram: () => void;
    loginByTwitter: () => void;
    loginByGoogle: () => void;
    loginByWallet: () => void;
    loginByEmail: ({ email, code }: {
        email: string;
        code: string;
    }) => Promise<boolean>;
    token: string;
    mid: string;
    did: string;
    address: string;
    isLogin: boolean;
    logout: () => Promise<void>;
    getLoginEmailCode: (email: string) => Promise<string>;
    refreshOverview: () => Promise<void>;
    overview: OverviewInfo | null;
    bindWallet: () => Promise<void>;
    bindTelegram: () => Promise<void>;
    username: string;
};

declare function useMatchEvents(handlers: IMatchEvents): void;

type ChainType = "ethereum" | "solana";
type RecoveryType = "base_generated_recovery_key" | "user_passcode_recovery_key"

interface UseWalletReturnType {
    initWallet: (params: {
        address: string;
        did: string;
    }) => Promise<void>;
    generateWallet: (params: {
        did: string;
        userPasscode: string;
    }) => Promise<string>;
    isRecovered: () => Promise<boolean>;
    recoveryWallet: (chainType: ChainType | undefined, recoveryType: RecoveryType, userPasscode?: string) => Promise<void>;
    signMessage: (message: SignableMessage, type?: ChainType) => Promise<Hex>;
    signTransaction: (transaction: TransactionSerializable, type?: ChainType) => Promise<`0x02${string}` | `0x01${string}` | `0x03${string}` | `0x04${string}` | viem.TransactionSerializedLegacy>;
}
declare function useWallet(): UseWalletReturnType;

declare const index_useMatchEvents: typeof useMatchEvents;
declare const index_useUserInfo: typeof useUserInfo;
declare const index_useWallet: typeof useWallet;
declare namespace index {
  export { index_useMatchEvents as useMatchEvents, index_useUserInfo as useUserInfo, index_useWallet as useWallet };
}

export { index$1 as Components, index as Hooks, MatchProvider, useMatch };
